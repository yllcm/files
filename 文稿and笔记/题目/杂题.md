### *loj2687. 「BalticOI 2013」Vim

[nealchen](https://www.cnblogs.com/nealchen/p/10162980.html)

线头 DP。

为了简化问题，我们先删掉文章中所有的 e，转化成：求最小步数，使得每个 e 后面的字符至少被经过一次。那么答案需要加上 e 的数量乘二（hx 删掉一个 e）。

此时问题结构相对静态，考虑 DP。考虑路径，它一定是由“飞线”和“跳线”构成。并且可以发现，跨过 $i/i+1$ 分界线的飞线最多两条，据此 DP，$f_{i,j,k}$ 表示跨过 $i$ 的两条飞线的字母为 $j,k$，其中 $j$ 在路径中靠前位置。据此 DP，随便写随便拍就搞完了，并不是很想讨论细节。

### *qoj4882. String Strange Sum

[题解](https://www.luogu.com.cn/blog/imustakioi/you-qu-di-chuan-chuan-ti) by 1kri。

我将问题模型看作了一个图论模型：对于某个特定的 $x$，对于 $i\leq x$ 对 $j\in[i,i+\text{lcp}(i,x)-1]$ 建边并找到和 $x$ 不连通的最大的点。这样是无法考虑的，因为建图本身带来的结构过于复杂。我转而考虑一个更简单的问题（实际上也没有多简单）：求出 $\sum_l f(l,n)$，但这无济于事。

上面的理解方式是没有前途的，我们不妨从前缀的角度来描述问题。一个串 $[l,r]$ 向左不能被覆盖的第一个点是它的所有前缀覆盖整个串，第一个没有被覆盖的点。考虑整个串，那么暴力做法就变成了：枚举串，枚举所有后缀，统计答案。既然涉及到了后缀，我们的问题讨论便可以转向 parent tree，尝试利用这个强大的结构来辅助我们优化。

考虑从 parent tree 的根节点开始 DFS，并在每个 endpos 集合统计答案，每次对于该结点的所有字符串进行一个覆盖。我们仅维护 endpos 集合，那么可以发现，endpos 集合之间的联通性构成若干个连续段。考虑维护这些连续段，我们需要维护的是把距离不超过当前长度的连续段合并，可以拿个堆维护可以合并的长度。递归到子树的时候，可以通过类似 dsu 的方法，暴力删除轻子树的结点，并令重儿子直接继承。

我也不知道我在讲什么。不过一些小想法是，对于环环相扣的问题，最初的暴力做法也许能决定整个算法的走向。

### 2023.6.8 联考 T1

**题意：**

给定序列，支持两种操作：

* 区间循环移位。
* 求循环移位次数使得逆序对数量最小。

**题解：**

实力降智。

考虑两个数 $i<j$ 的贡献，在移位次数小于 $i$ 的情况下，贡献是正的。$[i,j-1]$ 的时候，贡献是反的，$[j,n]$ 的时候是正的。研究一下 $i$ 处的差分数组就是 $i$ 之前比 $p_i$ 大的 $-$ $i$ 之前比 $p_i$ 小的 $+$ $i$ 后面比 $i$ 大的 $-$ $i$ 后面比 $i$ 小的，研究一下这个实际上就是 $n-p_i-p_i-1$。然后求最大前缀就完了。

转化至此就是平衡树板子了。我刻画的时候少写了一项贡献降智了好久。

### *2023.6.8 联考 T2

**题意：**

支持两种操作：

* 单点修改。
* 求 $\max_{|i-j|\leq k}\left(a_i+a_j\right)$。

**题解：**

想到了支配对但没想到是这样支配的，听说典题。

猜想我们需要考虑的点对并不多。观察一下可以发现假如我们选择最大的数，那么它周围的 $k$ 个数若在最优解中，则一定和它配对。正确性显然。

于是可以构造这样一个做法：分块，每块大小为 $k$，每次找到其中最大值更新答案。注意到一次修改最多影响相邻的两个块，暴力使用数据结构维护即可。

主要是支配对。这题传统数据结构方法是很难解决的，又因为其最优化问题的属性，故可以猜想需要考虑的点并不多，而最大值显然要考虑，故由此入手。

### *2023.6.16 南外考试 T2

**题意：**

计数长度为 $n$ 的数列的数量，使得 $a_i\in[l,r],\bigoplus a_i=k$。多组询问 $k$。

$1\leq n\leq 10^9,0\leq l,r,k\leq 2^{30}-1$。

**题解：**

见过好多次，但是不会/px

经典的套路是枚举第一个自由元素的位置然后乘式子。枚举有 $i$ 个数贴下界，其它 $n-i$ 个数贴上界。枚举位置可以得到 $\mathcal{O}(n^2\log r)$ 的显然做法。

考虑把两部分分开统计异或和，比如说钦定某一位异或和为 $w$，那么枚举当前位置选择 $1$ 的数量可以得到 $\sum\limits_{i=0}^x\dbinom{n}{i}v_1^iv_2^{n-i}[i\bmod 2=w]$ 这样的式子，单位根反演之后用一遍二项式定理即可。所以现在复杂度是 $\mathcal{O}(n\log r)$。

考虑拓展到正解，其实上面的推导过程已经引出了一种做法：再用一次二项式定理和单位根反演。但是讨论过于复杂。不过发现其实根本没必要推式子，DP 也是可以做的。在第一个自由元素出现的位置做 DP，对于一个元素，它的决策是：开始贴 $L$ / 开始贴 $R$，填上 $0$ / 填上 $1$。那么设 DP 状态 $f_{i,j,k}$ 表示当前异或和，是否有自由元素，有几个数贴了 $L$。最后一个条件是为了满足前缀相同的限制，不过其实不重要，我们只需要关注它的奇偶性。所以状态数只有 $8$，拿个矩阵乘一下就好了。

多组询问只需要预处理。

感觉不太会这种既可以的 DP 又可以推式子的题目。形式简单意味着我们有多种路径可以选择，恰当的选择能使推导过程更加清晰明确。

### *2023.6.16 南外考试 T3

**题意：**

给一个 $n$ 维度超立方体，第 $i$ 维度边长为 $p_i$。求最小链覆盖。

$n\leq 32$。

**题解：**

事先知道 Sperner 定理，猜测钦定一个和并计数和的个数即可。

不过结论可以更强。可以断言和就是 $M=\left\lfloor\dfrac{\sum p_i+n}{2}\right\rfloor$。

所以只需要求一个组合数：$\sum_S\dbinom{M-s(S)-1}{n-1}(-1)^{|S|}$。

注意到 $n\leq 32$，考虑 meet in the middle。问题在于怎么把组合数拆成两个独立的部分。写成下降幂的形式用下降幂二项式定理即可。

时间复杂度 $\mathcal{O}(n^22^{\frac{n}{2}})$。

### *2023.6.17 南外考试 T3

**题意：**

给定序列，支持：

* 区间进行一轮冒泡排序。
* 区间求和。

$n\leq 10^6,q\leq 10^4$。

**题解：**

巨大数据结构题。

讲一下冒泡排序只在 $[1,n]$ 的包。问题在于我们需要如何描述“一个序列被冒泡排序 $t$ 轮”之后的结果。考虑一次冒泡的实际过程：所有前缀最大值平移到下一个的位置，把 $0$ 删掉，把 $1,n$ 加进来。考虑维护前缀最大值的下标集合 $S$，那么对 $S$ 的操作就是全局减 $1$，单点加单点删。考虑对于其它元素，它们均往前平移了 $t$ 位，也就是说，这些数前面比它们大的数有 $t$ 个被扔后面去了。还有一些元素在操作之后变成了前缀最大值，显然它们是 $\{i|p_i\leq t\}$，其中 $p_i$ 表示 $i$ 前面比 $i$ 大的数的个数。这相当于一个整体平移。所以说每次暴力维护出 $S$  集合就好了，由于一个位置只会被加入一次，所以复杂度是对的。

我在思考这个部分分的时候疏于对冒泡排序过程的刻画并认为其不可维护（毕竟信息看起来非常不连续），然后就弃掉了。数据结构还是做得不够。

整体的问题考虑序列分块。序列分块需要支持的操作为：整体冒泡排序，开头加入一个更大的数（并排序），末尾加入一个更小的数。查询开头元素，查询结尾元素，查询区间和。整体冒泡排序可以利用上面的方法打标记解决，查询开头元素的话，可以发现开头元素一定是 $a_1\sim a_{t+1}$ 的最小值。查询结尾元素，则一定是全局最大值。

加入和删除比较棘手，因为我们必须在最初始的没有冒泡排序过的序列上进行操作，使得冒泡排序 $t$ 轮之后序列是我们期望的形态。在开头加入的话，直接把被删除的元素替换掉和冒泡排序 $t$ 次之后在加入开头元素等价。但是在末尾插入就比较棘手。如果直接加入的话，可能会出现 $t$ 次冒泡排序之后，原序列中的一些元素被放在了这个元素后面，这不是我们想要的。解决办法是在序列末尾插入 $t$ 个缓冲元素，这样做的话可以发现 $t$ 轮之后这个元素就和序列末尾接触了。

### *2023.6.21 南外考试 T1

**题意：**

定义区间的 $\text{mix}$ 为第二个没有出现的自然数，$q$ 次询问给定区间的子区间的 $\text{mix}$ 之和。

$n\leq 2\times 10^5,q\leq 10^6$。

**题解：**

由于 $\text{mex}$ 的删除性质比较良好，考虑倒着扫描线，每次删除一个数。首先，将一个数从一个区间内删除，区间的左端点为一个后缀。那么我们将这个数加入这些左端点对应的集合，$\text{mix}$ 即为次小值。观察 $\text{mix}$ 的变化，若 $mn<w$，那么 $cmn\gets mn$，否则若 $mn\leq w<cmn$，那么 $cmn\gets w$，因为 $mn,cmn$ 的单调性，我们只需要对两个区间分别做以上操作。线段树维护一堆标记即可，另外区间赋值可以理解为乘 $0$ 再加给定值，这样比较方便一些。

观察问题结构还是差了些，开始没意识到次小值的维护是简单明了的，即使感觉比较复杂也还是要把变化的过程写出来。

### *2023.6.21 南外考试 T2

**题意：**

交互题。

一棵树，初始可能在 $X$ 或者 $Y$。每次可以调用 $\text{move}(x)$ 表示走当前点的第 $x$ 条边，返回值为新点的度数。如果可以确定当前点的位置即输出当前点位置，否则无解，输出 $-1$。$n-1$ 次操作内确定位置。

**题解：**

要求确定序列 $a$ 使得 $X$ 和 $Y$ 走过序列 $a$ 之后，到达点相同或者点的度数不同。

观察到状态数只有 $\mathcal{O}(n^2)$，所以可以暴力 BFS。

考虑更加 nb 的做法。以重心为根，不妨令 $sz_x>sz_y$，我们要做的是不断减小 $sz_y$，将它逼到叶子。如果两个点对应父亲编号不同，那么 $x$ 往父亲走即可。否则两个点父亲编号相同，或者 $x$ 为根。对于前者，由于度数相同，所以一定存在一棵子树使得 $sz_y$ 更小。对于后者，由于 $x$ 多出来了一个可行的分叉，所以不一定。但是考虑 $y$ 删掉的是它的父亲子树，大小大于 $n/2$，$x$ 删掉的是任意一棵子树，大小小于 $n/2$，删完之后 $x$ 仍然更大，所以一定可以找到。

现在要解决 $sz_x=sz_y$ 的问题。由于根的 $sz$ 最大，所以可以让 $x$ 一路往根跳，直到两个点 $sz$ 不同。唯一的问题是，若跳到根且 $sz_y=n/2$，那么两边分别删去子树之后，子树大小仍然相同，无法操作。此时重心有两个，我们需要判断两棵子树是否同构（度数和编号意义下的），如果不同构就一起走直到找到子树大小不同的点，否则返回无解。

如此处理之后，再执行之前的做法即可。

所以为什么暴搜没想出来，以后做题要先编个做法，然后想优化策略。

### *2023.6.21 南外考试 T3

**题意：**

定义二叉树树的一个拓扑序的权值为任意前缀中，某个点左子树出现元素个数和右子树出现元素个数的差的绝对值的最大值。求所有拓扑序的权值和。

**题解：**

以后再来完善吧。

考虑 DP，问题在于求解如下模型：从 $(0,0)$ 走到 $(n,m)$，坐标差的绝对值不超过 $k$ 的答案，其实也即不碰到 $y=x-k-1$ 和 $y=x+k+1$ 的路径数。解决方法是反射容斥。假设我们钦定先碰到左边，那么我们将第一次碰到之前的路径沿左边直线对称，得到的新的路径由于要确保不先碰到右边路径对称过来的直线，所以需要递归地讨论类似的问题，递归的过程中做容斥。综上，答案是 $\dbinom{n+m}{m}+\sum_{i\geq 1}(-1)^i\left(\dbinom{n+m}{n-i(k+1)}+\dbinom{n+m}{m-i(k+1)}\right)$。

有了这个可以尝试 $\mathcal{O}(n^2)$ DP。不过考察这个 DP 实际的有效状态，$f_{i,j}$ 的 $j$ 有范围 $j\in[|sz_{ls}-sz_{rs}|,\max(sz_{ls},sz_{rs})]$，这个大小不超过较小的子树，也就是说，它是 $\mathcal{O}(n\log n)$ 级别的！加上上面的计算可以做到 $\mathcal{O}(n\log^2 n)$ 的复杂度。

子树和规模可能很大，但是加一个字，**轻**子树和，这个就比较小。

### *2023.6.25 南外考试 T3

**题意：**

长度为 $n$ 的字符串和 $a$ 数组，定义 $f(l,r)$ 表示子串 $[l,r]$ 中出现至少两次的字符串的最大长度。定义一个区间的代价为 $\max a$，$q$ 次询问代价最小的子区间使得 $f(l,r)\geq t$。

**题解：**

离线下来，考虑整体二分。那么考虑当前区间包含的子连续段，一定是若干个完整的连续段和 $\mathcal{O}(1)$ 个不完整的连续段，问题转化为：

* 求区间内 $f(l,r)$ 的最大值。
* 判断区间 $f(l,r)$ 与 $t$ 的大小关系。

二者可以在 $\mathcal{O}(\log n)$ 时间内完成相互转化，所以只需考虑后者。

条件等价于 $l\leq x\leq r-t+1,\text{lcp}(x,y)\geq t$。用 SA 刻画这个东西，从大到小合并 $\text{height}$ 连续段。因为只要考虑存在性所以我们只需要关注一个 $\text{height}$ 连续段中相邻的部分，而根据启发式合并，相邻点对的个数是 $\mathcal{O}(n\log n)$ 级别的。然后问题就是二维偏序，你可以用主席树做这个东西。

关于整体二分，每次加点的时候再用一个主席树即可。关于连续段查询，可以考虑如下算法：线段树维护左端点在当前区间里面的所有连续段，查询的时候，如果所有连续段都被完全包含，那么直接返回。如果不存在连续段与查询区间相交，也直接返回。递归到叶子的时候，对叶子结点的连续段与查询区间取交即可。所以总复杂度 $\mathcal{O}(n\log^2 n)$。

串串还是练少了，SA 不怎么会用，实际上这东西比 SAM 好用多了。另外支配对是线对级别的还没发现，当时主要卡在这里了。还是和上题一样，轻子树和其实挺小的。

### *2023.6.25 来源不明的题

**题意：**

给定数组 $a$，$q$ 次询问区间内两两异或最小的点对。

**题解：**

[支配对技巧小记](https://www.luogu.com.cn/blog/Lynkcat/post-7-yue-4-ri-bao-jia)

### 2023.6.27 南外考试 T1

**题意：**

一棵 $n$ 个点的树上有 $m$ 个僵尸，第 $i$ 个僵尸位置在 $x_i$，参数为 $h_i$。边有边权，僵尸只能通过边权小于其参数的边。现在第 $i$ 条边有 $[L_i,R_i]$ 的随机权值，求至少有一个点不能被僵尸到达的概率。

$n,m\leq 2000$。

**题解：**

容易被误导去想容斥。

你可以尝试设 $f_{u,i,j}$ 表示 $u$ 子树内安全点往上的最大边权是 $i$，传上来最强的僵尸是 $j$。但是发现如果有 $i$ 但是 $j$ 不能把 $i$ 干掉那 $j$ 啥用没有，因为干掉别的子树的不影响它合法。所以只需要记录一维即可，前缀和优化即可做到 $\mathcal{O}(n^2)$。

### *2023.6.27 南外考试 T3

**题意：**

$n$ 个点 $m$ 条边的图，可以选择两条边把边权设为 $1$，其余边权为 $0$。最大化最短路长度之和。

**题解：**

赛事 $m=n-1$ 想了一个类 [ZJOI2019]语言 的做法，然后发现自己是 sb，为啥非要讨论权值为 $\{0,1,2\}$ 的边数量呢。

$m=n-1$ 可以发现最短路就是路径上边的个数，所以可以考虑每条边的贡献然后取最大值和次大值。

考虑原题。

分类讨论几种情况：

* 如果两条边都是桥，套用上面的做法。
* 如果两条边一条边是桥，那么另外一条边啥用没有。
* 如果两条边都不是桥，那么肯定在同一个边双连通分量里面。在 DFS 树上讨论：
  * 如果两边都不是树边那么不管。
  * 如果一条边是树边那么另外一条边唯一，那么讨论连接删点后连接两个联通块的路径，其实上就是树边被覆盖次数。
  * 如果两条边都是树边并且两条边都不是桥，那么生成树被分成三个联通块，可以发现，如果图不联通，那么所有边都一定是跨过两条树边的。这相当于覆盖两条树边的集合相等，可以用 Hash 判断。而且发现两条树边具有决策单调性，可以拿分治做。

综上，复杂度两只 $\log$。

所以说在讨论双联通分量的时候还是把 DFS 拉出来比较好。

### *2023.7.4 南外考试 T3

**题意：**

一个括号序列，括号序列有红、蓝、绿三种颜色。每次可以把一个左括号变成右括号，或者把一个右括号变成左括号。问最少多少次操作才能使删掉红色和删掉蓝色所得到的括号序列均合法。

**题解：**

代码鸽了。

其实括号序列只有两种限制：

* 前缀和非负。
* 和为 $0$。

那么考虑先调整和然后再调整前缀和。调整和有很多方式，我们枚举绿色序列的和 $s$，那么蓝色和紫色序列一定是 $-s,-s$，然后发现如果和小了一定贪心地取最左边的右括号改成左括号，否则取最右边的左括号改成右括号，这样的操作是唯一的。

至此我们调整了和，现在我们需要在不改变和的前提下调整前缀和。那么考虑一种操作：把最左边的右括号翻转，把最右边左括号翻转。那么假设颜色 $i$ 执行了 $x_i$ 次上述操作，并令 $i$ 前面颜色 $j$ 的括号数量为 $p_{i,j}$，后面为 $s_{i,j}$，那么限制为 $\min\{p_{i,j},s_{i,j},x_i\}+\min\{p_{i,2},s_{i,2},x_2\}\geq \dfrac{-sum_i}{2}$，可以把两个 $\min$ 相加的合并起来得到 $9$ 个限制，那么所有限制形如：

* $0\geq c$。
* $x_i\geq c$。
* $x_i+x_2\geq c$。

所以可以用第一个判断有无解，第二个得到下界，满足第二个之后调整 $x_2$ 即可。可以利用线段树维护限制。

第一步是枚举一些量来约束操作，第二步是刻画限制寻求最优解。不容易发现的是所有操作都可以被描述为先调整和再调整前缀和的形式。

不懂啊，咋想到的。

### *2023.7.7 南外考试 T1

**题意：**

给定排列 $a$，每次可以选择 $x$ 执行 $\text{swap}(a_x,a_x+1)$。假设操作次数为 $\text{opt}$，最小化 $\sum_{i}[a_i\neq i]+\text{opt}$。

**题解：**

困难。

发现 $\text{opt}$ 是 $\mathcal{O}(n^2)$ 量级，但是前面是 $\mathcal{O}(n)$ 的，说明操作使得目标函数减少的情况其实很少。考虑一个置换环，$sz-1$ 次操作最多使得前面减少 $sz$，并且操作是唯一的，所以我们需要判断什么时候一个置换环内的数可以通过 $sz-1$ 次操作拆开。

容易得到一些简单的结论：

* 所有数在原排列下标和值均连续。
* 原序列中所有数逆序对数恰好为 $sz-1$。

所以考虑找到这些连续段，并做一个 DP。直接做是平方的，但是可以发现，如果一个连续段内包括另一个连续段，那么直接操作更小的连续段是更优的，所以我们只需要找到某个右端点最小的连续段。连续段合法的条件为：

* $\sum_{i=l}^r a_i=\sum_{i=l}^r i$，且 $\max_{i=l}^r a_i=r$，对于值域连续的刻画。
* 逆序对数为 $r-l$。

第一个条件可以单调栈+前缀和找到唯一的位置，只需要判断这个位置的逆序对数即可。注意到它的值域是连续的，所以逆序对可以拆成 $[1,r],[1,l-1],[1,l-1]\times [l,r]$ 计算，主席树可以维护。

关键在于观察到第一个结论。

### *loj3395.「2020-2021 集训队作业」Yet Another Permutation Problem

答案是 $n-\text{longest increasing subsequence}$。

考虑这个怎么算，如果每次往后面加一个连续段，需要记录最大值，末尾的排名，这样是四次方。

考虑观察限制的形态，发现对于一个分段方案，限制形如不等关系，那就把小于号全部容斥掉。记录 $w(i,j)$ 表示连续的 $i$ 个小于号限制，其中最长连续段为 $j$ 的容斥系数。这样是三方。

考虑计算最长子段 $\leq k$ 的方案数，问题相当于半在线卷积。但是！不是 NTT 模数，所以不能用多项式科技。此时只能找一找容斥系数的规律，发现只有 $\dfrac{n}{k}$ 个位置有值，直接暴力可以做到 $\mathcal{O}(n^2\log n)$。

### *2023.7.8 南外考试 T2

**题意：**

$n\times n$ 的棋盘，有 $k$ 个位置不能选。问有多少种选恰好 $m$ 个棋子的方案，使得：

* 每行每列至少有一个棋子。
* 主对角线和副对角线至少有一个棋子。

**题解：**

对 $k$ 个棋子容斥，然后 DP，总复杂度 $\mathcal{O}(2^kn^4)$。

我写的是对行列容斥然后 DP，最多只能做到 $\mathcal{O}(2^{2k}n^4)$，这东西甚至没跑过暴力。

所以我真的不会容斥。。。

### *2023.7.10 南外考试 T1

**题意：**

树上修改一条边的颜色，查询一条路径上是否颜色互不相同，强制在线。

**题解：**

关键转化：设 $a_i$ 为 $i$ 颜色出现次数的异或和，那么互不相同当且仅当 $a_i$ 的异或和中为 $1$ 的个数为路径长度。

有了这个可以直接树分块维护两边 bitset。

### *2023.8.7 模拟赛 T1

**题意：**

有一个 $X\times Y$ 的方格纸，对于一个矩形 $(x_1,y_1,x_2,y_2)$，可以这样覆盖（大概就是四个方向取区间或者区间补）：

![](https://cdn.luogu.com.cn/upload/image_hosting/m9rnj2s1.png)

然后你找一种覆盖方式使得被 $n$ 个矩形覆盖的矩形最多。

**题解：**

直接枚举决策是 $\mathcal{O}(4^n\text{poly}(n))$ 的，太不牛了！

然后你很会联合省选 D2T2，所以可以枚举一个点，然后让其它的矩形都包含这个点，这样是 $\mathcal{O}(n^3)$ 的，太不牛了！

尝试观察一个方格被包含的条件，发现要所有矩形都是朝向它的方向，那么考虑多个方格同时被包含的条件，发现需要 $n$ 个矩形同时包含它们的朝向相同，使用 XOR-hashing，可以做到 $\mathcal{O}(n^2)$。

发现横纵决策是独立的，每维分开做可以做到 $\mathcal{O}(n)$。

关键在于，你得感受这个条件，而不是瞎找性质。

我怀疑我有些智力障碍。

### 2023.8.7 模拟赛 T3

**题意：**

给定序列 $a$ ，对于所有排列 $p$ 求：
$$
\sum_p\prod_{i=1}^n\frac{1}{\sum_{2\leq j\leq i} a_{p_j}}
$$
**题解：**

神必组合意义。

如果是 $1\leq j\leq i$ 的话，后面的答案相当于有 $n$ 个颜色，每个颜色有 $a_i$ 个，要求颜色最后一个出现的标号是最大的，并且最后一个出现的顺序为 $p$。如果不枚举 $p$ 的话，答案就是 $\prod_{i=1}^n\dfrac{1}{a_i}$，表示编号最大的在最后。

但是它是从 $2$ 开始的，说明第一个没必要考虑最后一个最小。考虑咋计数，其实枚举第一个之后随便容斥就好了。

### *P8923 『MdOI R5』Many Minimizations

非常好题目。

考虑内层问题怎么求。根据 slope trick 的结论，维护集合 $S$：

* 每次加入两个数 $a_i$。
* 删掉 $S$ 中最大的数。

最后的答案为 $\sum a_i-\sum S_i$。只需要求 $\sum S_i$。

这个转化太牛逼了！内层本质是 DP，但是实际上可以用更加简洁的信息概括。

考虑怎么求 $\sum S_i$，直接维护堆有点超前，考虑差分缩减值域。具体地，把 $\leq x$ 的数标为 $0$，$>x$ 的数标为 $1$，枚举 $x$，只需要求最后 $1$ 的个数。可以做到 $\mathcal{O}(mn^2)$（使用 DP，考虑每次加入 $1$ 或者加入 $0$，转移形如 $(i,j)\to (i+1,\max(j-1,0)),(i,j)\to (i+1,j+1)$） 

发现这个东西很像格路计数，但是 $\max(j-1,0)$ 的限制较难处理。考虑把下面的部分拉上来，形成正常的折线，这样子问题形如：从横坐标为 $0$ 的任意位置开始走到 $(n,i)$ 的方案数，容易发现这样可以构成以 $(0,0)$ 为起点的路径的双射。

推个式子发现是关于 $x$ 的多项式，暴力求出多项式套自然数等幂和即可。写的斯特林数。

推式子的时候差点忘了上指标求和了……

### *loj3570. 「COCI 2021.11」嫌疑人

写个证明。

明确一下题意：构造操作最少的方案使得对于任意身高情况均能查出嫌疑人。

先考虑 $l_i=r_i$ 的情况。猜测最优方案一定是从左往右，每次找到以 $x$ 为左端点（初始 $x=1$）的最大区间 $[x,y]$，使得 $[x,y]$ 没有重复元素。操作区间 $[x,y]$，并令 $x\gets y+1,ans\gets ans+1$，重复上述过程。

考虑归纳证明。结论对于长度为 $1$ 的序列显然成立。对于长度 $n>1$ 的序列，假设第一次操作中，最优方案 A 操作了 $[1,x]$（假设 $x<n$），另一种可能的方案 B 操作了 $[1,y]$ 使得 $y>x$。容易发现的事实是，做完前者后，问题变成 $[x+1,n]$ 的子问题，做完后者后，问题变成 $S+[y+1,n]$ 的子问题，其中 $S$ 是 $[1,y]$ 中出现了至少两次的元素按原序列顺序排列得到的序列。若方案 B 没有删去任何元素，那么显然不优，否则我们将问题归到了规模更小的子问题，根据归纳假设，此时最优方案一定是每次找到左侧最大的不重复区间。设方案 B 第一次操作完之后的第二次操作为 $[1,z]$，显然 $z<|S|$，并且 $S_z\leq x$，否则 $x$ 一定可以更大。那么在这次操作的同时，我们对方案 A 操作 $[x+1,y]$，此时可以发现，方案 A 经过两次操作后的序列一定为方案 B 的子集，所以一定更优。

知道最优策略之后，我们着手考虑 $l_i\neq r_i$ 的操作，注意到若两个区间有交，那么它一定在某种情况中相等，此时需要把它分开。那么此时第一个区间的定义是：最长的区间使得区间内的区间两两交集为空。考虑对于每个左端点找到最优的右端点，此时需要找到 $suf_i$ 表示 $i$ 后第一个与 $[l_i,r_i]$ 交集非空的区间。可以使用线段树解决：每次加入区间 $j$ 的时候，在线段树上的 $[l_j,r_j]$ 区间执行对 $j$ chkmin。查询 $suf_i$ 的时候，找到 $[l_i,r_i]$ 的区间最小值即可。找到 $suf_i$ 之后，我们对其求一个后缀 $\min$ 即可得到结果。暴力模拟跳跃可以做到 $\mathcal{O}(n^2)$。

考虑优化模拟，发现如果将 $i$ 跳跃到的节点作为 $i$ 的父亲，则我们会得到一棵树，在树上倍增即可做到 $\mathcal{O}(n\log n)$。

[代码](https://loj.ac/s/1856988)，写的是从右往左跳。