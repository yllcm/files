既不会智力题也不会套路题的憨批选手。

做题太少了！以后 30min 之后处于没思路游离状态直接看！

### *CF1830C Hyperregular Bracket Strings

**题意：**

计数括号序列的数量，使得指定区间均为合法括号序列。

**题解：**

交叉不是很好处理，考虑转化一下条件：

* 如果 $[l_1,r_1]\subseteq[l_2,r_2]$，那么条件相当于 $[l_1,r_1],[l_1,l_2)\cup(r_1,r_2]$。
* 如果交叉，那么就是交叉的三个区间。

把这个扩展一下就可以发现所有条件是不交的，并且两个位置在同一个条件里面需要满足覆盖它们的区间相同，使用 XOR-hashing 解决。

### CF1830D Mex Tree

**题意：**

在树上填上 $0,1$，最大化两点间 mex 和。

**题解：**

一个构造是黑白染色。稍加转化可 以发现实际上要最优化 $x+2y$，其中 $x$ 表示只有 $0$ 的路径，$y$ 表示只有 $1$ 的路径。直接 DP 可以平方，但是最优构造实际上给出了上界，所以背包容量是 $\mathcal{O}(\sqrt{n})$ 的。

### CF1827B2 Range Sorting (Hard Version)

**题意：**

一个序列，每次可以给区间 $[l,r]$ 排序，花费代价 $r-l$。求每个子段排成升序的代价之和。

**题解：**

考虑怎么求单组，发现单组就是这个东西：
$$
\sum_i[\text{premx}_i\leq \text{sufmn}_i]
$$
然后扩展到多组：
$$
\sum_{l=1}^n\sum_{r=l}^n\sum_{i\in[l,r]}[\max(l,i)\leq \min(i+1,r)]
$$
枚举 $i$ 并大力维护所有 $\max(l,i)$ 和 $\min(i+1,r)$ 的信息，前者可以用一个单调栈维护，后者可以用可以撤销的单调栈维护，线段树维护点积，复杂度 $\mathcal{O}(n\log n)$。

### CF1827C Palindrome Partition

**题意：**

给定字符串，求多少个子串能被划分成若干个偶数回文子串。

**题解：**

粗暴的想法是 DP，但是因为划分方案是不同的所以可能会重复。所以可以尝试找到唯一的划分方案。

一个想法是每次删掉最长回文后缀，但是它不能建立到其它划分方案的对应。但是手玩可以发现较短的串是可以建立对应关系的，也就是说，如果一个串有偶数回文前缀，那么它可以被更短的回文串覆盖掉。

考虑证明这个结论。假设回文 border 的长度不超过 $len/2$，那么直接分成三段就好。归纳证明这个结论，假设前缀的长度为 $p$，那么存在长度为 $len-p$ 的周期，那么回文前缀会存在一个长度为 $p\bmod(len-p)$ 的 border，即长度为 $p-p\bmod (len-p)$ 的周期，根据短周期引理，原串存在更短的周期。如此直到 $len-p=0$ 位置。

那么只需要找到某个串的最短偶数回文后缀即可。

感觉是这场唯一有意思的一道题。

### CF1827D Two Centroids

愚蠢的树剖板子题。

### CF1838F Stuck Conveyor

看了题解才想到要优化掉一个 $\log$。呜呜。

这种交互题的一般思路是考虑如何步步缩小范围，也就是说，如何判断一个矩形区域里面有无坏掉的点。首先我们肯定希望每个格子都被经过一次，那么可以考虑蛇形构造，但是可能会混过去，所以做一半之后还要倒着 check 一遍来保证正确。分别二分行和列即可得到一个 $4\log n$ 的做法，加了随机扰动还是过不去。

注意到我们每次要询问两次有点浪费，考虑优化掉一次。主要的问题是我们并不知道卡的方向，所以不知道哪个方向会卡。那么可以想到开始先整体询问一下，显然有一个方向会被卡住，之后每次都拿卡住的那个方向问就可以了。

注意点在边界的情况要特判。

### CF1824D LuoTianyi and the Function

更适合中国宝宝体质的 DS 题。

考虑找到每个元素最后出现的位置，那么答案就是这些最后出现的位置的最大值。考虑扫描线，用 set 维护最后出现的位置，问题相当于区间加和查询区间历史和。这个随便做。

### CF1819E Roads in E City

麻了，咋都是神秘题。

考虑一个更简单的问题：加边删边和询问连通性。那么可以尝试问出一棵 DFS 树，询问的方法是尝试删边，如果不联通那就加回去，容易证明最后会得到一棵树。查询非树边就在树上删一条边然后加回来。

你问我怎么询问删一条边之后图的连通性？每次随机边的两个端点可以得到 $\dfrac{1}{2}$ 的正确率。

### CF1819D Misha and Apples

*2800？可能是因为前面的题太难或者法太多了吧……

枚举最后一个清空的位置，考虑什么时候 $[1,i]$ 可以清空。枚举上一个清空的位置 $j$ ，那么需要满足：

* $[1,j]$ 可以清空。
* $[j+1,i-1]$ 不清空。
* $i$ 恰好清空。

转化一下条件。第一个条件是一个子问题。第二个条件需要满足区间内集合没有交集，第三个条件需要满足 $[j+1,i]$ 之间有空集或者与 $i$ 有交的集合。

所以考虑一个 DP，注意到合法转移位置是一个区间，利用数据结构容易维护转移。

因为清空是暴力枚举 $1\sim m$ 法了一发。

### *CF1342F Make It Ascending

这是一个 $\mathcal{O}(3^nn)$ 的做法。

先转化一下题意：假设我们确定了不删的元素集合 $A$，我们需要把删掉的数的值加到 $A$ 中的数上使得 $A$ 构成一个递增序列。

一个简单的想法是设 $f_{w,j,S}$ 表示目前 $A$ 的最后一个元素为 $j$，值为 $w$，已经用掉了 $S$ 中的数的最大答案。这个做法是不能接受的，因为 $w$ 达到了约 $10^7$ 级别。

注意到 $f_{w,j,S}\in [1,n]$，所以考虑交换值域和一维 DP 状态。重新定义 DP 数组的含义：$f_{i,j,S}$ 表示答案为 $i$，$A$ 中最后一个元素为 $j$，已经用掉了 $S$ 中的数，最后一个元素的值最小是多少。

暴力的转移即：枚举所有状态，枚举 $S$ 的补集的子集 $T$，满足 $s(T)>f_{i,j,S}$（$s(T)$ 表示 $T$ 中所有元素的和）。令 $t=\min\limits_{x\in T,x>j}x$，执行转移 $f_{i+1,t,S\cup T}\gets s(T)$，这样转移是 $\mathcal{O}(3^nn^2)$ 的，一脸不能过的样子~~虽然它过了~~。

考虑优化，发现转移的值和 $f_{i,j,S}$ 无关，于是可以考虑先枚举 $S$，并将 $\{a_{i,j}\}=f_{i,j,S}$ 和 $\{s(T)|T\cap S=\varnothing\}$ 放在一起排序，得到一个新的序列。我们从前往后遍历新的序列，并同时维护数组 $mx_i$：若当前遍历到的元素为 $f_{i,j,S}$，我们对 $k\geq j$ 执行 $mx_k\gets \max(mx_k,i)$，即表示在 $k$ 之前的最大的答案。若当前遍历到的元素为 $s(T)$，则可以枚举 $t\in T$ 并执行转移 $f_{mx_t+1,t,S\cup T}\gets s(T)$。

分析复杂度，排序的复杂度不超过 $\mathcal{O}((2^nn^2+3^n)\log(2^nn^2+3^n))=\mathcal{O}(3^nn)$，转移时两部分的复杂度分别为 $\mathcal{O}(2^nn^3)$ 和 $\mathcal{O}(3^nn)$。综上，总时间复杂度为 $\mathcal{O}(3^nn)$。 

### *CF1392H ZS Shuffles Cards

首先可以写一个 DP。定义 $f_{i}$ 为还剩 $i$ 个没摸出来的期望。转移式子：
$$
f_{x}=\sum_{l=0}^x\sum_{i=0}^n\binom{x}{l}\binom{n-x}{i-l}i!\frac{m(n-i-1)!}{(n+m)!}(f(x-l)+i+1)
$$
虽然这东西特别复杂但是它确实能推。。。。前缀和可以做到 $\mathcal{O}(n)$。完全不会这种暴推式子的题。

### *CF1616H Keep XOR Low

人类智慧，不知道咋想到的。

按位考虑。假设我们现在锁定了两个值域区间 $A,B$，我们需要在 $A,B$ 两个集合中各至少取一个数使得它们之间两两异或和小于 $x$。按照数位 DP 的想法，$A,B$ 都仍然顶到了上界。

分类讨论下一位填法，不妨设 $X$ 在当前位为 $1$。如果下一位填 $(0,0)$ 或者 $(1,1)$ 那就没啥问题，可以直接算。如果有 $(\{0,1\},0),(0,\{0,1\})$ 之类的情况，可以发现两个 $0$ 是不用管的，只需要选 $(0,1)$ 的对然后拼上一个 $0$ 即可。$(\{0,1\},\{0,1\})$ 也是类似的，只需要构造 $(0,1)$ 和 $(1,0)$ 然后拼起来即可，直接拼起来两个集合是不相互影响的。

直接 Trie 树上递归的复杂度是 $\mathcal{O}(n\log w)$。

大概懂了，或许是注意到 $a_i\text{ xor }a_j$ 涉及到的有效的限制并不多。

### *CF1503E 2-Coloring

这不会？这不会？这不会？这不会？这不会？这不会？这不会？这不会？

手玩 / 打表可以发现表格是这样的形式：蓝色和黄色分别为至多两个联通块，中间存在一列分界线，然后两边是轮廓线，具体可以看题解的图。

看到这应该就会做了，但是我手玩假了，寄。

### *CF1815E Bosco and Particle

什么神秘人类智慧。

对于每个 $i$，把除了 $i$ 其外的其它都删掉然后跑一遍，假设从 $0\to 1$ 有 $a_i$ 次，$1\to 2$ 有 $b_i$ 次，那么 $i-1\to i$ 和 $i\to i+1$ 的次数为 $ka_i$ 和 $kb_i$。另一个条件是 $a_i=b_{i-1}$。

于是找到满足条件的最小的 $a$ 数组即可，具体可以主元 $f_0$，然后维护质因子次数。

### *CF1621G Weighted Increasing Subsequences

相当于求：
$$
\sum_{i=1}^n \text{LCS}(i,p_i)\sum_{j<i}\text{LCS}(j,i)
$$
$p_i$ 表示最后一个大于 $i$ 的元素。这个是不合法的方案，要减掉。

那考虑一个上升子序列涉及的贡献。首先末尾元素是后缀最大值，其次只有 $p_i$ 为末尾元素的 $i$ 才有贡献。

发现有贡献的值是一个后缀，那么我们求出 $p_i$ 之后 DP 的时候只保留有效的贡献就好了，容易用 BIT 维护。

不过我觉得 cxy 的解释更加自然：注意到 $p_i$ 是有特殊性质的，它是可能成为上升序列的最后一个元素，所以此时进行 DP 的话状态数是 $\mathcal{O}(n)$ 的。其实状态一直都是 $\mathcal{O}(n)$ 的（指 $\text{LCS}(i,p_i)$，这个状态可以相互转移）

### *CF1810G The Maximum Prefix

想了一个小时，然后灵光一现突然想到优化方法，不知道考试的时候能不能灵光一现。

三次方是一个这样的东西：$f_{i,j,k}$ 表示当前前缀为 $j$，最大前缀为 $k$。

考虑差分，求最大前缀不超过 $k$ 的答案。最后的答案就是 $\sum f_i(h_{i}-h_{i+1})$。

所以现在有个做法就是：枚举 $k$，然后设 $f_{i,j}$ 表示当前前缀为 $j$ 的答案。

不过你发现你其实一直在干重复的事情，考虑放一起做。此时突发奇想发现条件只和 $k-j$ 有关，那么 $k$ 就没用了。所以设 $f_{i,j}$ 表示距离限制为 $j$ 的方案数。至于贡献，初始化的时候提前乘进去就好了。复杂度是 $\mathcal{O}(n^2)$ 的。

### *CF1810H Last Number

牛逼题（话说你是一点也不自己想啊）

打表观察可以知道，整个过程分成两个阶段。对于 $S_{\max}>2S_{\min}$，设其为 $1\sim p-1$ 次操作，剩下的为 $p\sim n-1$ 次操作。前者满足 $S_\min=i$，后者满足 $S_\min$ 为上一次操作产生的值。

转化到这里还有一点头大，进一步分析，利用第二阶段 $S_\min$ 为上次操作产生值的性质，更深入地描述问题。第 $p$ 次操作的产生的值为 $r_p-p$，其中 $r_p$ 为 $p$ 次操作的最大值，那么 $p+1$ 次操作即为 $r_{p+1}-(r_p-p)$，进一步地，可以得到最后的答案为 $r_{n-1}-(r_{n-2}-\cdots-(r_p-p))$。更进一步地，我们需要知道 $\sum(-1)^{n-i+1}r_i$，即可求出答案。

诶但你这什么都没做啊，不过是重写了一遍问题而已嘛。尽管如此，上述过程依旧给了我们一个明确地推导方向：描述 $r_i$ 以快速求值（不像我做题的时候一直在找规律，找不到就不会做了……）

可以发现，第二阶段产生的数不会出现在 $r_i$ 中，所以我们需要考察第一阶段中 $r_i$ 的取值。第一阶段的 $l_i$ 有着很好的性质，有助于我们分析。如果立足于整个序列，新产生的数的不规律的插入不利于我们分析，但是这一部分中新插入的数是递减的，我们不妨着重分析已经确认了的位置。观察（懒得写了去 Alex_wei 老师题解看吧）可知，进行一次操作之后，新插入的数满足：

* $r_i=r_{i-1}$，则新插入两个 $r_i-l_i$。
* $r_i=r_{i-1}-1$，则新插入一个 $r_i-l_i$ 和两个 $r_i-l_i-1$。

观察其差分数组，发现上述过程可以抽象成这样一件事情：有一个字符串 $s$，生成方式为：对于一层元素，将 $0$ 变为 $10$，$1$ 变为 $110$，以得到下一层元素。设 $s$ 的前缀和为 $h_i$，则 $r_i=n-h_i$。

带入原式子可以得到一个隔一个位置求和的式子，由于生成方式呈指数级增长，容易在 $\mathcal{O}(\log n)$ 时间内查询前缀和。

上述过程，观察整体形态，刻画答案，刻画 $r_i$，一气呵成，这种过程复杂的题需要这样清晰的刻画过程。

但是上面那个 1815E 大概真就是猜出来的，它可能只有观察问题整体结构一步（小声）

### *CF1810F M-tree

经典套路：$m$ 叉树合法的叶子的深度序列满足 $\sum_i m^{-dep_i}=1$。

所以需要找到最小的 $X$ 使得 $\sum_im^{a_i-X}\leq 1$。相当于求出 $\log \sum_{i}m^{a_i}$。

应该没有人用[实数维护](https://codeforces.com/contest/1810/submission/210347778)吧？采用 ODT 维护大数进位，复杂度 $\mathcal{O}(n\log n)$。

### CF1809G Prediction

挺简单的，转化一下题意就会做了。

### *CF1808E3 Minibuses on Venus (hard version)

如果这题能用单位根反演，我将绝杀，可惜不能。

有一个简单 $\mathcal{O}(k^2\log n)$ 做法。注意到 $n$ 个数求和等于任意数的方案数为 $k^{n-1}$，需要特判 $n=0$。枚举和并容斥计算，每次考虑删掉一个数之后背包的答案。可以利用二项式反演：$\sum_{i=0}^{n-1} \dbinom{n}{i}(-1)^ik^{n-i-1}+f(S)$。$f(S)$ 为禁止位置为 $S$ 并且塞满的方案数。关键在于计算 $f(S)$。先考虑 $S$ 是个啥。如果 $k$ 是奇数那么 $S$ 只有一个数，一个数塞满的方案数容易计算。如果 $k$ 是偶数那么 $S$ 有两个数，两个数的话枚举第一个数选的数量模 $k$ 的余数即可计算出合法的数量。问题在于求 $\sum_{t}\dbinom{n}{tk}$，使用范德蒙德卷积拆开可以得到 $\mathcal{O}({k^2}\log n)$ 做法。

不过如果考虑一个线性 DP：$f_{i,j}$ 表示选到 $i$ 个数和为 $j$ 的方案数，可以证明这个 DP 中本质不同的数并不多。转化一下问题，假设枚举的和是 $s$，禁止位置为 $x$，我们令 $s\gets s-nx,x\gets 0$，得到的问题和原问题等价。如果再考虑上面的 DP，即可发现非 $0$ 位置的 DP 值是相等的。所以状态数是 $2$。如果有两个不同的数，那么其中 $0$ 和 $k/2$ 相同，其余相同，状态数还是 $2$。所以可以 $\mathcal{O}(k+\log n)$。

不过观察转移式子发现转移和枚举的和无关，关键在于 $s-nx$ 是否为 $0$ 或者 $k/2$。这个……使用简单的数论推导技巧即可求得。复杂度 $\mathcal{O}(\log k+\log n)$。

关键在于观察到 DP 的值不多，只能说别惦记你那组合数了。

### *CF1806F2 GCD Master (hard version)

牛逼猜结论题，啥时候我才能猜出结论呢。

假设所有数互不相同。然后我们随便拉一些情况出来调整。比如说合并三个数 $\{a,b\},\{c,d\}$，尝试这样操作：$\{a,b,c\},d$，考虑啥时候答案会变大。前者可以得到 $\gcd(a,b)+\gcd(c,d)$ 的结果，后者可以得到 $\gcd(a,b,c)+d$ 的结果，先把 $\gcd(a,b)$ 代换成 $g$，那就是 $g+\gcd(c,d)$ 和 $\gcd(g,c)+d$ 比一下，假设 $g<d$，那么前者如果比较大：$g-d>\gcd(g,c)-\gcd(c,d)$，但是 $\gcd(g,c)\leq g$ 所以基本上没啥救，并且如果 $g,c,d$ 互不相同的话前面是严格劣的，如果 $g=c=d$ 的话倒是可以取到等号。

所以你发现大的往小的放挺优秀的。假设所有元素互补相同，那么我直接大力往小的调整！可以发现最后只剩下一个集合了，所以只需要最大化 $\gcd(S)-sum(S)$。存在显然的 $\mathcal{O}(m\log m)$ 做法。如果有相同元素的话，那就一部分操作去重一部分操作合并即可。

F2 需要进一步发掘性质。因为上面的讨论发现选和尽可能小的比较优秀，我们不妨假设先选择最小的前 $k$ 个元素，然后调整。先随便调整两个数 $k+1<i<j$。那么和至少增加 $a_i-a_j$，但是 $\gcd$ 至多是 $a_i-a_j$，所以不会调整超过两个数。

还可以更强！假设我们把 $i<k$ 调整到后面的 $j$，和至少增加 $a_j-a_k$，$\gcd$ 至多也是这么多，所以只会调整 $a_k$。

所以求 $\max_{j>k} \gcd(a_1,\cdots, a_k,a_j)-a_j$ 即可。因为重复元素的存在，需要对多个 $k$ 求值。不过 $\gcd$ 的变化是 $\log$ 的，所以可以只重构 $\log$ 次。复杂度 $\mathcal{O}(n\log^2 m)$。可以均摊计算 $\gcd$，这样少一个 $\log$。

### *CF1805F2 Survival of the Weakest (hard version)

牛逼题。但是不会 F1 多少带点抽象。

考虑如果能求出每次迭代的结果能够立即得到一个 $\mathcal{O}(n^3)$ 的做法，问题在于值域很大，所以你要考虑怎么存下来这堆数。仔细观察可以发现极差是递减的，所以可以只存最小值和每个数与最小值的差。

考虑优化单次询问，可以排序后直接模拟加入，复杂度 $\mathcal{O}(n\log n)$。某人脑抽写了 $\mathcal{O}(n\log V)$ 的二分。

考虑推广到正解。我们猜想：有用的元素并不多。

考虑 $a_n$ 啥时候才有用，假设 $a_1=0$，显然你要满足 $a_n\leq a_2+a_3$，也即 $a_n\leq 2a_3$，此时迭代的下一层对应的数是 $\{a_2,a_3,\cdots a_n\}$，再往下走 $a_n$ 必然会减去 $a_3$，那么 $a_n$ 就会衰减至少一半。所以大约 $\mathcal{O}(\log V)$ 次操作 $a_n$ 就会衰减到 $0$，所以我们猜想：某个元素的有效时间不超过 $\mathcal{O}(\log V)$，也即：只保留前 $2\log V$ 个元素可以求出正确答案。

证明：如果 $a_L>a_2+a_3$，那么只需要用前 $L-1$ 个元素即可求出所有 $L$ 个元素。如果 $a_L\leq a_2+a_3$，那么操作一次之后，$a_{1\sim L-1}$ 是对的，再操作一次，$a_{1\sim L-2}$ 是对的，我们不妨把后面两个元素删去。由于第二种情况只会发生 $2\log V$ 次，所以有效序列长度至多减少这么多。

所以只保留前一部分元素大力做即可。

### *CF1801E Gasoline prices

脑抽了。

考虑另外一个知名问题 [SCOI2016]萌萌哒。显然这个题也可以 $\mathcal{O}(\log n)$ 归约到上面的问题，所以只需要考虑链上的版本。

但是这个在线比较烦，不过你考虑并查集合并次数并不是很多，所以可以考虑一个均摊。每次合并两个集合的时候暴力递归两边集合合并，如果两个集合已经在一个集合里面就退出。因为一共只有 $\mathcal{O}(n\log n)$ 个集合所以复杂度是均摊 $\mathcal{O}(n\log n\alpha(n))$。

但是实际上可以更加直接。我们每次找到链上的所有有效的位置然后暴力合并，关键是怎么求出一条链上两个链上所属的集合是不是全部相等。首先如果用路径压缩的话不好维护出每个点所属的集合，所以需要按秩合并。其次判断全部相等可以倍增哈希。那这样复杂度是 $\mathcal{O}(n\log^2 n)$。

### *CF1799H Tree Cutting

首先如果需要考虑连通块是子树或者子树补的话不太优美，所以可以直接枚举一个在最终集合中的点，这样保留的联通块就确定了，然后用 $|V|-|E|$ 容斥确定最后的答案，但是这里最后的 $|V|$ 是确定的所以不用。

考虑设计一个 DP。DP 的通用思路是：先确定组合对象的一部分，看剩下的部分是否分成若干个独立的子问题。如果考虑每一步删去的子树大小的话不太好做，但是实际上可以考虑每一步删去了多少个节点。假如说我最后一步刀在 $u$ 的父亲，那么我需要保证 $u$ 的子树内还剩下 $sz_u-(s_{k-1}-s_k)$ 个节点，那看起来就和其它没啥关系了，但是我不确定有哪些步数刀在当前子树里面，所以状态压缩一个 $s$ 表示刀了哪些点就好了。于是可以设 $f_{u,i,s}$ 表示 $u$ 子树剩 $i$ 个节点，$s$ 集合内的步数刀在 $u$ 子树里面。但是你发现确定了 $s$ 实际上可以导出 $i$，所以没必要记录 $i$。换根就可以做到 $\mathcal{O}(n3^k)$。所以为啥 $n$ 出 $5000$。

关于 DP 状态设计的部分是启发性的。

### CF1797F Li Hua and Path

建立重构树，转化成重构树上子树关系问题，等价于二维偏序。

### *CF576E Painting Edges

动态线段树分治（？

注意到图的心态依赖于之前询问的答案，但是没关系，我们仍然可以只添加边，确定一次询问的答案之后，我们将这次询问和下次这条边被修改的位置加入这条边，然后就是线段树分治了。

### ?CF671E Organizing a Race

得到充要条件之后设计贪心策略，然后二分的时候在线段树上快速模拟贪心的结果。

但是为啥我的充要条件只能 $\mathcal{O}(n\log ^3 n)$？我甚至刻画了最小操作次数，这不科学。

### *CF1408H Rainbow Triples

诶嘿这个我会，还是比较有意思的。

考虑枚举 $b_i$ 的集合然后贪心找 $a_i,c_i$，然后可以设计一个贪心：从前往后配对，每次去最早的前面的 $0$ 和最早的后面的 $0$ 然后配对。

然后你发现这个条件还可以倒着，接着可以发现一个固定的构造：取最前面 $x$ 个 $0$ 和最后面 $x$ 个 $0$，按顺序匹配。

那么假如枚举颜色集合的话只需要每个颜色选一个塞到一个区间里面，使得每个区间都被塞了一个颜色即可。这个东西是匹配问题，转 Hall 定理变成了一个点匹配一个区间的颜色，问完美匹配。乍一看不太好做，但是这个区间并必然是一个区间，扫描线一下即可。

但是其实没必要二分啊！这个判断是增量的。

### CF1726G A Certain Magical Party

瞎写的东西过了，震撼。

假设最终的数是 $X>\max a_i$（$X=\max a_i$ 稍后讨论），考虑合法的条件。设最终的排列为 $p$，需要满足：

* 若 $b_{p_i}=0$，那么 $\sum\limits_{j>i}[a_{p_j}<a_{p_i}]=X-a_{p_i}$，这是因为前面的 $j<i$ 的 $p_j$ 都已经操作过了，现在它们开心值是 $X>\max a_i$，不可能比 $a_{p_i}$ 小。
* 若 $b_{p_i}=1$，那么 $\sum\limits_{j>i}[a_{p_j}>a_{p_i}]=X-a_{p_i}-(i-1)$，这是因为前面操作过之后值为 $X>\max_j a_j\geq a_{p_i}$，所以它加上的值为后面比它大的值和前面所有数。补集转化一下变成 $\sum\limits_{j>i}[a_{p_j}\leq a_{p_i}]=n-i-(X-a_{p_i}-(i-1))=n-X+a_{p_i}-1$，这是一个定值。

所以尝试按照 $a_i$ 从小到大的顺序插入排列。

先考虑 $a_i$ 互不相同的情况，那么可以发现，$a_i$ 插入的位置是固定的，因为我们需要保证有定值个比 $a_i$ 小的数排在 $a_i$ 后面，所以容易确定 $a_i$ 的位置。

再考虑 $a_i$ 可能相同的情况。$b_i=0$ 的情况稍简单，我们首先讨论。显然，所有满足 $a_i=y,b_i=0$ 的数插入的位置一定在确定的两个数之间，且不同的数之间可以任意排列，所以假设这样的数有 $c_0$ 个，方案数为 $c_0!$。再讨论 $b_i=1$ 的情况。可以发现，若有两个数 $p,q$ 满足 $a_{p}=a_{q}=y,b_{p}=b_{q}=1$，那么 $a_p$ 和 $a_q$ 后面小于等于它们的数必定不相等。假设 $p$ 插入排列中的位置 $pos_p<pos_q$，那么 $p$ 后面小于等于 $y$ 的数有 $a_q$ 和 $a_q$ 后面所有小于等于 $y$ 的数，这显然严格大于 $a_q$ 后面小于等于 $y$ 的数，所以出现两个以上 $a_i=y,b_i=1$ 的方案数是 $0$，否则方案数是 $1$。

注意到对于方案数的讨论与 $X$ 无关，这说明对于任意 $X>\max a_i$，方案数是相等的。不过我们需要考虑 $X$ 的范围。对于 $b_i=0$，需要满足 $X-a_i\leq \sum_{j\neq i} [a_j<a_i]$，对于 $b_{p_i}=1$，需要满足 $0\leq n-X+a_{i}-1\leq \sum_{j\neq i}[a_j\leq a_i]$。扫一遍判断即可。

接下来只需要讨论 $X=\max a_i$ 即可。不过可以发现，这种情况与上面的情况唯一的区别是，对于 $a_i=\max_j a_j,b_i=1$ 的数，它可以放在排列中任何位置，而其余条件与上面相同，所以假设这些数的个数为 $c_1$ 个，将答案乘上 $n^{\underline{c_1}}$ 即可。

时间复杂度 $\mathcal{O}(n)$。

### *CF1534G A New Beginning

不会做！

尝试写一个暴力。关键在于找到某个点到路径的切比雪夫最小点。可以发现一定是它下面的一条线和右边的一个角。但是这样只能三次方。

但是一件比较显然的事情是我们只需要考虑 $x+y=x_i+y_i$ 这条直线和路径的交点，所以只要考虑一个点就行了！然后就可以平方了！

然后发现这东西是凸的！因为贡献是凸的，$f_{i,j}=\min(f_{i-1,j-1},f_{i-1,j+1})$ 的转移式子得到的结果也是凸的（这东西相当于往差分数组里面塞两个 $0$）。可以用平衡树维护插入结点和区间加。但是没必要，因为斜率差很小，所以考虑 slope trick，用 multiset 维护斜率的拐点（也就是相当于某个点处的拐点数量为原数组的二阶导）。往中间塞两个 $0$ 相当于斜率 $0$ 左侧的拐点向左平移一格，斜率 $0$ 右侧的拐点向右侧平移一格。所以用两个 multiset 维护斜率 $0$ 左侧和右侧的所有拐点即可。

注意 slope trick 我们也不知道开始值，所以我们一般维护斜率 $0$ 处的权值而不是值域左侧的权值，一般斜率 $0$ 的权值就是答案。

### *CF1491H Yuezheng Ling and Dynamic Tree

注意到这个操作性质很差，所以一般只能考虑暴力，然后分块平衡一下。

考虑分块，维护每个位置的 $nxt_i$ 表示 $i$ 向左跳第一个跳出块的位置。区间修改的时候直接散块暴力，但是整块不好打 tag，所以还是只能暴力。但是可以发现整块 tag 如果大于 $B$ 的话 $nxt_i=a_i$，所以只需要重构 $B$ 次，总复杂度是 $B^2\dfrac{n}{B}+\dfrac{n^2}{B}$，平衡一下就是单根号。

### *CF1801G A task for substrings

就，挺玄乎的。

做一步这样的转化：求出 $[1,r]$ 和 $[1,l-1]$ 的答案，然后减去左端点在 $[1,l-1]$ 右端点在 $[l,r]$ 之间的贡献。

建立正串和反串 ACAM，那么左端点的串为 $[1,l-1]$ 的后缀，可以利用 ACAM 上 $[1,l-1]$ 对应状态的祖先结点来刻画，另一边同理。相当于是说，要求合法的 $(x,y)$ 数量，使得 $x$ 是 $u$ 祖先，$y$ 是 $v$ 祖先，且 $x+y$ 为 $s_i$ 中的数。但是你发现本质不同的 $(x,y)$ 只有 $|S|$ 种，所以可以二位数点做。

根据上述做法可以得到一个分治做法。两种做法都是将“子串”转化为一个前缀和后缀，也即更为简单的独立的两部分。我得到了复杂度为根号的扫描线做法，但是子区间统计问题不能忽视分治，子区间统计问题不能忽视分治，子区间统计问题不能忽视分治。分治是会多一个 $\log$ 的，上述做法给出了分治的一种替代方案，但是使用方法有额外的限制，目前来看要保证 $[1,r]-[1,l-1]-[1,l-1]\times [l,r]$ 的容斥成立。

### *CF1842H Tenzing and Random Real Numbers

挺怪的。

如果大力画一些类似高维凸包的图 CPU 会炸掉，所以不能这么做。

转化一下原问题的条件，即我们需要满足：$x_i\leq 1-x_j$ 或者 $x_i\geq 1-x_j$。这是一个序关系，比刚才那个线性规划好做得多。

但是这个序关系并不守序善良，因为 $x_i$ 有 $x_i$ 和 $1-x_i$ 两种形态。不过你可以发现如果 $x_i,x_j\leq \dfrac{1}{2}$ 的话一些条件就没用了。所以可以枚举 $x_i,x_j$ 与 $\dfrac{1}{2}$ 的大小关系，然后只需要考虑异侧的元素。

现在我们通过手动枚举加入了一些限制并去除了一些限制，总体来说问题变简单了。因为有 $x_i\leq \dfrac{1}{2}$，所以我们设 $x_i=\dfrac{1}{2}-y_i$，带回去发现序关系变得善良了。状态压缩枚举序并处理选边的问题，复杂度 $\mathcal{O}(2^n n)$。

其实很多这种不等式都是描述的都是序，从线性规划的角度来考虑可能麻烦很多。可能是为啥有个问题叫保序回归。

### *CF1842G Tenzing and Random Operations

这个题也好玩。

~~首先如果操作之间没有区别那这个题就是 calc，用拉插即可。~~

直接考虑 $a'_i$ 没啥前途，因为这东西很大。直接考虑 $a'_i=a_i+b_iv$ 也没啥前途，因为 $b_i$ 也巨大。

但是你可以用一些神秘拆贡献方法。也就是说把 $a'_i$ 拆成 $a_i+v+v+v+\cdots$ 这种东西，然后每次选一个乘上去。这个操作相当于把原先的 $\prod a_i$ 拆成了若干个组合对象，其对象有其新的权值。

那考虑在 $i$ 处的决策：

* 选 $a_i$，这个直接乘就完事了。
* 选 $v$。这个要考虑前面的操作带来的影响，分两种情况讨论。
  * $v$ 在前面用到的 $v$ 所属的操作中出现了。
  * $v$ 是一个新的操作，之前还没用过。

那么可以这么定义状态：$f_{i,j}$ 表示 $i$ 之前用到的 $v$ 属于 $j$ 个不同的操作，可以根据上面的定义转移。

看来我对计数一无所知.jpg

不过这个拆乘法的东西我之前在模拟赛里面见过，但是由于过于粗暴所以没去想，其实这个拆乘法挺有用的。

### CF1792F1 Graph Coloring (easy version)

观察条件，一张图显然会被其中一种颜色连通，另一种颜色不连通。考虑另一种颜色的连通块，容易发现这些连通块导出子图仍然满足条件，所以就独立了。DP 直接做即可。hard version 套个多项式即可，懒得写了。

### *CF1787G Colorful Tree Again

动态 DP 的做法可以看我的题解。

正统做法是，把每条路径看成一个点，把路径上的点向路径连边，所得的图一定是一棵树。那么每个点拿 multiset 维护儿子的最大值，再拿一个 multiset 维护全局最大值即可，删点只需要把它的父亲单点删掉，并且把它的权值从全局 multiset 删掉即可。

把限制建图，观察限制间的依赖关系。

当时想了每条边长度为 $1$ 的时候还是不会做，有点菜。邻域信息可以考虑儿子父亲分开维护。

### *CF1785E Infinite Game

以为是 DP of DP，瞎造个自动机大小为 $5\times 10^5$，理论上能过的样子但是跑 $24s$，吐血。

其实有更快的做法。我的暴力做法是：预处理出从 $1,2,3$ 开始的 Alice 与 Bob 的数量差，最后模拟判断环上节点个数的大小关系。

但是你发现你根本没用到 $(c_1,c_2,c_3)$ 这个三元组的信息，你只用到了其中在环上的几个的和。所以可以枚举哪些在环上然后只记录和的信息，最后再模拟。

### *CF526G Spiders Evil Plan

典。来补一下代码。

考虑没有限制一定经过某个点怎么做。那么策略一定是：第一步选择直径，后面选择按照直径为根进行长链剖分，剩下的最长的链。

可以证明，如果钦定包含 $x$，那么策略为：

* 删掉一条最短的链，加上包含 $x$ 的链。
* 把 $x$ 最近的在联通块中的祖先 $v$ 下面的链拐过来。
* 把 $v$ 上面的链拐过来。

大力求就好了。

### CF1693E Outermost Maximums

简单题，但是编了好久。

考虑怎么决策，可以发现如果按照值从大到小考虑的话，每个点肯定选左侧和右侧最大值最小的一边，容易发现是可以取到的，所以你可以 $\mathcal{O}(ans)$。

考虑怎么优化。如果把每个点的轨迹建成图的话相当于求每个点的链的长度。从小到大构造链比较麻烦，考虑从大到小做。枚举值，考虑哪些位置会经过这个值，推一推可以发现充要条件是它上次操作之后，左侧和右侧都有比它小的值，或者左侧和右侧都有在这次操作被拉下来的值。那么可以考虑维护每个点的状态：左侧有比它小的，右侧有比它小的，然后到每个值的时候找到左侧最小的左侧有值的位置和右侧最大的右侧有值的位置，区间加上答案，然后更新左右侧每个点的状态。矩阵可以维护。

但是写一发发现 T 了，不过发现左侧有值右侧没有的为一个前缀，右侧同理，所以直接线段树维护点积即可。

### *CF1817E Half-sum

首先你可以写出答案式子，其次你发现答案式子是若干个 $2$ 的整次数幂的和，所以可以用数据结构维护大数加法。但是 $\mathcal{O}(n\log n\log V)$ 的复杂度比较难受，不过你可以压位给弄到 $\mathcal{O}\left(\dfrac{n\log n\log V}{w}\right)$，希望大家不要去写这个做法。

比较拟人的做法是观察到答案的差分数组是 $\dfrac{dif_{i+1}}{2^{n-i}}-\dfrac{dif_i}{2^{i-1}}$，那么 $ans_j-ans_i=-\dfrac{dif_i}{2^{i-1}}+\sum\left(\dfrac{1}{2^{n-t+1}}-\dfrac{1}{2^{t-1}}\right)dif_t+\dfrac{dif_{j+1}}{2^{n-j}}$。假如两个数都在前一半那么中间显然小于 $0$，如果 $dif_i>0$，那么剩下两项的差 $\dfrac{2^jdif_{j+1}-2^{n-i+1}dif_i}{2^n}$ 在 $dif_i\neq 0\land n-i+1>j+\log V$ 的时候毫无悬念，所以 $i+j<n+\log V+1$。如果 $i\leq \dfrac{n}{2}-\log V,dif_i>0$，那么最小的 $i$ 肯定是前半部分最优的，否则逐一检查 $i>\dfrac{n}{2}-\log V$，后半部分同理。

等价的实现是找前 $30$ 个检查。

所以这个题根本的矛盾在于大数比较需要 $\mathcal{O}(n)$ 的开支，两种思路分别是：利用数据结构加速比较和加法 / 减少比较次数。减少比较次数的话，猜想是有效的决策点比较少，由于答案已经有了很好的刻画，所以可以考虑大力比较两个决策点来获取结论。

### CF1783G Weighed Tree Radius

考虑怎么判断 $r$ 是否合法，需要存在 $u$ 使得 $\forall v,d(u,v)\leq r-a_v$，相当于 $r-a_v$ 能覆盖到的点有交，相当于两两有交。那么 $r-a_u+r-a_v\geq d(u,v)$，所以只要求 $\max a_u+a_v+d(u,v)$。

### *CF1776M Parmigiana With Seafood

首先 $n$ 是偶数答案一定是 $n$。下面只讨论 $n$ 是奇数。二分，如果叶子有黑点那么 Alice 必胜。

考虑链的合法条件。可以发现，如果最远的两个点距离为奇数那 Alice 一定能取到。取完其中一个就得到子问题。推广它，可以发现 Alice 能取到当且仅当存在两个点距离为奇数。证明即考虑，如果两个人的策略都是能取黑色点就取，不能取尽量取叶子，那么对于任意两个点，取完两边的步数一定是奇数，此时一定由 Bob 来剥其中一个叶子，然后 Alice 直接取即可，所以两个点一定能取到其中一个。

那么推广到树，条件是否仍然是充要的呢？充分，但是不必要。考虑七个点的图，结构为中间一个点连三条长度为     $2$ 的链，Alice 一样能赢。推广，如果有一个点连三条链，链底都是黑点，那么 Alice 也能赢。证明考虑三个点带上外面一个叶子的虚树，节点数量为偶数，这样肯定是 Bob 取一个叶子，然后 Alice 直接拿。

事实上三个点的条件相当于关键点的虚树点数为偶数，且条件是充要的，所以可以证明不满足的话 Bob 能把黑点拿完。

复杂度 $\mathcal{O}(n\log n)$。

### *CF1773J Jumbled Trees

麻了，碰到构造题就无能为力。

考虑一个构造，就是找一棵生成树，然后把树边做一次 $w$，非树边做一次 $-w$，这样相当于把非树边转移到树边。

这个做法组合出了一个更简单的操作。发现这个操作在和为 $0$ 的时候非常牛逼，只需要把操作建图然后找生成树就可以了。关键是和不为 $0$，那么随便找一棵生成树把和弄成 $0$ 就好了！！！！

关于为啥这样是对的，可以看 Alex_wei 的题解。事实上，所有生成树都可以表示成换一条边的生成树的线性组合。

“组合操作”“逐个击破”是构造问题的利器，我们需要通过组合操作简化问题，然后解决特殊情况，逐步引向正解。

### *CF1773G Game of Questions

好题，开始去想容斥了，后来发现 DP 就行了。

原题可以被转化为如下形式：

* 排列 $T$，使得如下过程进行后 $1\in S$：若 $S\cap T_i\neq \varnothing,S\gets S\cup T_i$。

考虑 $T_i$ 是否包含 $1$，如果 $T_i$ 不包含 $1$，那么限制相当于 $S\cap T_i=\varnothing$，不会进行任何操作，我们将其称之为“限制集合”，否则称之为“操作集合”。

注意到限制与 $S$ 有关，并且操作过程中 $S$ 总向它的子集移动，不妨以 $S$ 为阶段设计一个 DP。我们需要满足所有限制集合都为当前集合的超集。那么限制集合的可行位置一定是一个后缀。由于需要保证 $S$ 的形态，操作集合的可行位置也是后缀。那么我们实际上将集合分为了若干类，我们需要保证每类的第一个元素一定是操作集合，且操作后集合为我们想要的集合，并且每类的第一个元素递增。

假设第 $i$ 类集合大小为 $a_i$，第一个元素选择方案数为 $b_i$。那么考虑从后往前构造，设构造后 $i$ 个的方案数为 $f_i$，那么：
$$
f_i=f_{i+1}b_i(a_i-1)!\binom{a_i-1+\sum_{j>i}a_j}{a_i-1}
$$
可以发现，最后的答案为：
$$
n!\prod_i\frac{b_i}{\sum_{j\geq i}a_j}
$$
所以考虑在 DP 的过程中计算后缀和和 $b_i$。枚举集合 $T\subsetneq S$，假设 $cnt$ 个集合为 $S$ 超集，有 $val_{S,T}$ 个元素使得操作后 $S$ 变为 $T$，转移式子：
$$
f_S=\frac{1}{n-cnt}\sum_T f_T val_{S,T}
$$
直接转移复杂度 $\mathcal{O}(3^mm)$。

这个 $val$ 其实是可以 $\mathcal{O}(3^mm)$ 求的。假设 $p\notin S$，那么：
$$
val_{S,T}=val_{S\cup\{p\},T}+val_{S\cup \{p\},T\cup\{p\}}
$$

### CF1768F Wonderful Jump

说实话不如值域分治+李超树做到 $\mathcal{O}(n\log^2 n)$。

首先 $\min(j,i)$ 和 $i-j$ 至少一个小于根号。其次只有 $\min(i,j)=i/j$ 的时候才会转移。

$i-j$ 小于根号是容易处理的，$\min(i,j)=i$ 且小于根号也是容易处理的。$\min(i,j)=j$ 且小于根号可以发现如果我暴力找到上一个不超过 $a_i$ 的位置然后转移复杂度是正确的根号，所以总复杂度 $\mathcal{O}(n\sqrt{n})$。

### *CF1765J Hero to Zero

白学了，真白学了。

题目相当于最大化 $\sum a_i+\sum b_i$ 满足 $a_i+b_i\leq c_{i,j}$。可能最近被结论题整傻了所以想去推一些结论。但实际上这东西很像 KM 解决的问题所以它实际上就是 $c_{i,j}$ 的最小完美匹配。相当于求排列 $p$ 使得 $\sum |a_i-b_{p_i}|$ 最小。

### *CF1762G Unequal Adjacent Elementsa

好题，喜欢。

首先显然大于 $\dfrac{n}{2}$ 就无解。

其次有一个特殊的构造：如果众数就是 $\dfrac{n}{2}$，那么就直接构造。

一个可行的思路是，分段，然后每段众数都是 $\dfrac{n}{2}$。但是不一定能分，所以要修。

问题在于，如果做到最后一段，当前分完之后后缀的众数已经是 $\dfrac{n}{2}$ 了，那么如果再分下去后面就不合法了。所以不能分。解决办法就是，保留已经分好的部分，然后把后面的众数隔一个塞一个，剩下的数按照大小顺序隔一个塞一个。容易发现是不会重叠的。

最后对于分好的每一段，如果开头元素相同了就交换一下奇偶就好了，显然是可以交换的，如果不能的话说明末尾两个元素一样。

这个从特殊构造的扩展真没想到，好像大部分构造都是这样做的，不过自己遇到这种智慧题就比较喜欢钻牛角尖。

### *CF1758F Decent Division

偶尔的灵光一现。

感受一下：最后的区间一定是相隔不远的一段 $1$ 构成一段连续的区间，相隔比较远的两个 $1$ 可以用两个区间分别包括。可能存在方案使得这相邻的两个 $1$ 被包含在同一个区间，不过处于简洁考虑，我们将其分开，并将不可分开的子区间称为“基本的”。

考虑这些基本区间满足的条件，由于不能被分开成为两个 $01$ 相等的子区间，所以这个区间必须满足：将区间中的 $1$ 看做 $1$，$0$ 看做 $-1$，那么区间内的前缀和始终 $\geq 0$。

于是可以很自然地想到利用括号序列刻画这个 $01$ 序列。将 $1$ 看做左括号，$0$ 看成右括号，那么我们可以维护当前括号序列的所有合法括号子串。那么考虑翻转一个括号带来的影响：

* 右括号变成左括号，那么当前子区间的合法区间会扩大，线段树二分找到这个右端点。
* 左括号变成右括号，那么当前子区间会多出来两个不匹配的右括号，这两个右括号将整个区间分为不超过 $2$ 个合法括号子串。暴力找到这两个括号子串即可。

所以利用线段树维护前缀和，用 map 维护区间就做完了。

不过提早考虑前缀和的话问题似乎没那么难以捉摸，还是太菜了。

最近总是沉迷于找一些性质，但其实也没什么性质能找，一般都是用常用的工具刻画一下，或者拿一些方法做一下，就行了。很多题能观察的其实不多，关键在于构建模型。

### *CF1748F Circular Xor Reversal

很 edu。

可以造出来一个简单的操作：先做一遍 $j-1\to i$ 的后缀和，然后倒过来 $i+1\to j$ 还原作为一次操作，可以在中间的数不变的情况下使得 $a_i\gets \bigoplus_{k=i}^j a_k$。在拿这个组合，可以通过两次操作使得 $a_i\gets a_i\oplus a_j$。再组合，可以通过三次上面的操作做到交换两个数（`x^=y^=x^=y`）

上面这个第一步没想出来，步步组合操作真不是这么好组合的。事实上第一步挺好想的，但是没这个意识。

直接做可以 $3n^2$，但是不能过，所以我们要考虑合并一些重复的操作。设一次 $a_i\gets a_j$ 为 $f(i,j)$，发现如果 $f(i,j)$ 不还原 $i+1$ 的话，得到的结果就是下一个 $f(i+1,j-1)$ 的结果，所以可以合并这两个操作。

所以操作数量减半，次数为 $1.5n^2$。

### *CF1747E List Generation

不是吧，这都不会？

显然：
$$
\sum_{k\leq lim} k\sum_{i<k}\binom{k-1}{i}(-1)^i\binom{k-i+n-3}{n-1}\binom{k-i+m-3}{m-1}
$$
枚举 $t=k-i$：
$$
\sum_t \binom{t+n-3}{n-1}\binom{t+m-3}{m-1}\sum\binom{k-1}{t-1}(-1)^{k-t}k
$$
后面那个单组合数是可以递推的。

就是说，这种基础计数咋就做不对呢。

### *CF1740G Dangerous Laser Power

抽象题，如果能想到构造所有都合法的解之后就很简单。

但是没有想到/fn

### *CF1738G Anti-Increasing Addicts

Anton 题。

可以观察到 $n^2-(n-k+1)^2$ 就是保留若干个点且链长不超过 $k$ 的上界，具体可以考察每个主对角线的最大点数。

接下来就是构造，根据 Dilworth 定理，最长链等于最小反链覆盖（第一次用这个定理），所以我们要用 $k-1$ 条不交反链覆盖所有点。考虑直接贪心覆盖，具体地，假设 $f_{i,j}$ 为 $(i,j)$ 为结尾的最大链长，我们在覆盖所有 $f_{i,j}=d$ 的点的前提下尽可能往右走，来保证 $k-1$ 条链是不交的。容易证明这样做是对的。考虑到 $f_{i,j}=d$ 的点是个单调序列，我们维护后缀最大值即可快速判断。

“尽可能往右走”确实有那么一点点感性，不过在限制复杂以至于无法得到一个简洁的结论时，只能通过这样一个贪心来解决问题了。

另外偏序集的知识，最长链等于最小反链覆盖。

### *CF1735F Pebbles and Beads

相当于每次对一条直线做闵可夫斯基和，所以可以维护一下凸包。

做闵可夫斯基和的时候，sb 才维护凸包上的点，实际上维护一下直线和直线在 X 轴上跨过的长度就好了。用 multiset 维护。

注意要用 long double。

### *CF1728F Fishermen 

为啥这种题做这么久。

首先你得意识到如果互不相同那么答案就是和。所以我们实际上要找到 $b_i$ 使得 $a_i|b_i$ 并且 $b_i$ 互不相同。那么这就是个匹配问题。直接费用流是 $\mathcal{O}(n^4)$ 的，但是流量比较特殊，它只和最后一条边有关，所以可以贪心找到这条边然后类似匈牙利的过程跑增广路。复杂度是 $\mathcal{O}(n^3)$ 的。

### *CF1322E Median Mountain Range

考虑如果只有 $0,1$ 咋做，稍微模拟一下可以发现对于一段长度为 $len$ 的连续的 $01$，需要 $\dfrac{len-1}{2}$ 次操作变回来，并且最终前一半是和左端点颜色相同，后一半和右端点颜色相同。

可以考虑从小到大枚举 $mid$，把不超过 $mid$ 的标为 $0$，其它标为 $1$。分析和上面类似。如果要求具体数组，整体二分是 $\mathcal{O}(n\log^2 n)$ 的，但是实际上可以直接从小到大扫，每次维护新出现的段并覆盖变成 $0$ 的位置，这样是单 $\log$。

模拟赛场上发现数据结构维护比较复杂就没往下做了，最后才发现是可以维护的……

### *CF1725D Deducing Sortability

对[这份提交](https://codeforc.es/contest/1725/submission/181399323)的做法的说明~~官解我没看懂~~。

先转化一下问题。考虑矩阵 $A_{i,j}$ 表示 $i$ 操作 $j$ 次之后得到的结果，有 $A_{i,j}=2(A_{i,j-1}-2^{j-1})$，稍加推导可以得到封闭形式 $A_{i,j}=2^j(i-j)$。注意矩阵实际上是一个上三角的形态。

考虑二元组 $(i,A_{i,j})$，我们要做的实际上是：选出 $n$ 个二元组，使得它的第二关键字互不相同，并且将其按照第二关键字排序之后，第一关键字构成的序列按照题目定义尽可能小。

接下来给出结论：

> 结论 $1$：策略一定是先选择前 $x$ 行中互不相同的数，再在第 $x+1$ 行选择一个后缀。

证明先考虑前半句话，如果前 $x$ 行没有被取满，那么从后面删掉一个数并从前面加上一个数一定更优。后半句话不影响和，但是让最后一行的第二关键字尽可能大可以保证字典序最小。

一个等价的结论是，取数的顺序一定是按行数从小到大排序，列数从大到小排序的顺序依次选取。

问题在于如果按照这个策略取，如何定位到第 $n$ 个互不相同的数的位置。这个问题的关键在于考虑 $x$ 会在矩阵的哪些位置出现，假设 $x=2^ty$，其中 $y$ 为奇数，那么有 $x=A_{y+t,t}=2^t(y+t-t),x=A_{2y+t-1,t-1}=2^{t-1}((2y+t-1)-(t-1)),\cdots$。在遍历过程中，第一个出现的为 $A_{y+t,t}$。观察可知，对于所有 $i-j$ 为奇数的 $A_{i,j}$，$A_{i,j}$ 都是在遍历序中第一次出现的。

> 结论 $2$：所有有效的位置 $A_{i,j}$ 满足 $i-j$ 为奇数，即矩阵黑白染色后的所有黑色格子（$A_{1,0}$ 为黑色）

所以求和就简单了，枚举完整的行数，如果某一行不完整就去掉一个前缀即可。

接下来需要解决查询的问题，即所有二元组 $(i,A_{i,j})$ 中，第 $k$ 大的 $A_{i,j}$ 的 $i$ 是多少。

继续观察所有选取的 $A_{i,j}$ 排序后的形态，可以得到：

> 结论 $3$：选取的 $A_{i,j}$ 排序后构成 $\mathcal{O}(\sqrt{n})$ 个等差数列，第 $i$ 个等差数列的公差是 $2^{i-1}$。

另一个等价的描述是，考虑选取的 $A_{i,j}$ 构成的上三角区域，第 $0$ 列的最后一个数 $A_{2t+1,0}=2t+1$ 满足所有 $[1,2t+1]$ 都在选取的区域中出现过。接下来，将第 $0$ 列删去，并将剩下的数全体除以 $2$，仍然满足这个结论。

证明只需考虑对于所有 $2^y(x-y)<2t+1$，都有 $x<2t-1$。当 $x\geq 2t-1$ 的时候，$f(y)=2^y(x-y)$ 在 $y\in[0,x-1]$ 时的最小值在 $y=0$ 时取到。考虑其导数 $f'(y)=2^y\ln 2(x-y)-2^y$，可知 $f(y)$ 先递增后递减，而 $f(x-1)=2^{x-1}\geq x$。所以结论成立。

所以考虑第 $k$ 大在哪个等差数列取到即可。设 $f_i$ 表示最高次幂为 $i$ 的数的个数，那么第 $i$ 个等差数列的大小为 $2f_{i-1}-1$，带入 $f_0$ 可以理解。而在第 $i$ 个等差数列里面找到第 $k$ 个数的位置是简单的，在第 $1$ 个等差数列中，第 $k$ 个数即为 $k$，找到 $k=2^xy$ 的表示即可。对于剩下的数，可以沿用上面的操作，处理完第一个等差数列之后，将全体数除以 $2$，依次类推。

总复杂度为 $\mathcal{O}(\sqrt{n})$。

### *CF1705F Mark and the Online Exam

我是傻逼选手。

你考虑怎么问出三个。首先考虑可以拿这个操作干什么，显然你可以问出某个集合的和。但这还不太够，你其实可以问出两个元素的差，如果只考虑和的话是做不出的。

考虑三个怎么做，可以询问 TTT、FFF 问出和，然后询问 FTF 和 TFF 问出差，总共四次操作。

然后考虑怎么两次操作问出三个。对于前面的操作，可以发现 FFF 没必要问很多次，问一次 FFFFFFF…… 就好了。后者同理，只需要问一次 TFTFTF…… 即可。

所以总共 $666+3=669$ 次。

### CF755F PolandBall and Gifts

考虑怎么做最少，可以发现答案要么是 $k$ 要么是 $k+1$，答案为 $k$ 当且仅当环能组合出 $k$。可以做背包，暴力做是平方的，考虑 $\sum sz_i=n$，所以本质不同的数个数只有 $\sqrt{n}$ 个，可以考虑把这些数拿出来做多重背包，多重背包用二进制分组优化可以做到 $\mathcal{O}({n\sqrt{n}\log n}/w)$，不过这东西跑的飞快。

考虑怎么做最多，直接贪心。删掉一个数会使得答案增加 $2/1$，那么每次取尽可能大的环即可。

主要是这个背包比较牛逼。

### CF762F Tree nesting

大力造自动机然后 DP，代码有一点点难写。

### *CF1712F Triameter

存在基于点分治的简单 $\mathcal{O}(nq\log n)$ 做法，但是这样是不够的，我们需要做到 $\mathcal{O}(nq)$。

假设 $g_u$ 表示离 $u$ 最近的叶子，我们需要求 $\max_{x,y}\min(g_x+g_y+t,dist(x,y))$，这个形式是可以二分的，换句话说，我们可以判断是否存在 $x,y$ 满足 $\min(g_x+g_y+t,dist(x,y))\geq mid$，然后这里就拆开了（实际上 $\max,\min$ 相关都推荐二分试试），所以需要满足 $g_x+g_y+t\geq mid\land dist(x,y)\geq mid$，使用长链剖分是可以解决的，具体地，记 $f_{u,i}$ 表示 $g_x\geq i$ 的最大 $dep_x$ 的值，每次加入一棵子树的时候，都在 $i+j+t\geq mid$ 的 $i,j$ 中查询 $f_{u,i}+f_{v,j}-2dep_u$ 的值。但是你发现没必要二分，因为答案比较小，所以可以直接暴力扩展答案。时间复杂度 $\mathcal{O}(nq)$。

所以这种树上距离问题是有时是可以通过长剖做到线性的。

### *CF1844F2 Min Cost Permutation (Hard Version)

关爱智障儿童。

首先可以猜出来 $c\geq 0$ 是不降序，$c<0$ 是不升序，可以取到最优。

对于 $c<0$ 最优化字典序，考虑套用字典序最优化的贪心 trick，可以枚举插哪个数，然后 $\mathcal{O}(1)$ 判断插完之后的最优解是否仍然是原最优解。 这是 $\mathcal{O}(n^2)$ 的。

如果大力拆开那个条件可以发现就是剩下的数排序后 $a_{j+1}-a_{j-1}\geq c\land b_{i-1}+c\leq a_j$，用 set 维护前面每次查的时候 lower_bound 即可。如果没找到就取最大的数。复杂度 $\mathcal{O}(n\log n)$。

猜出来最优结论不会最优化字典序，真的抽象。

### *CF1844G Tree Weights

人做的？

考虑求出每个点到根的距离，条件是 $dis_i+dis_{i+1}-2dis_{\text{lca}(i,i+1)}=d_i$。

然后呢？先求出 $dis_i\bmod 2^k$ 的值，然后可以递推出 $dis_i\bmod 2^{k+1}$ 的值，因为 $dis_{\text{lca}(i,i+1)}$ 只需要知道 $2^k$ 的值就可以知道两倍的值。

复杂度 $\mathcal{O}(n\log n+n\log V)$。

### CF1852D Miriany and Matchstick

你根本不是构造！

考虑 DP，直接 bitset 可以做到 $\mathcal{O}(\frac{n^2}{w})$，过不了。

考虑观察 DP 的过程，发现合法的位置形如区间，但是可能中间会少一些数。

不过少的数的级别是常数的！直接写就过了！

### *CF1672I PermutationForces

写了三个假做法，每个假做法 $200$ 行！无语了！

其实很简单，如果放在坐标轴上观察可以发现如果进入 $y=x-s$ 和 $y=x+s$，那它就不会出去了，所以可以平方。

考虑什么树套树上挂减半警报器，这样就可以 $3\log$ 了，太快了！

考虑找性质，发现如果有直线上如果一个点被二维偏序那它一定后加入，下方同理，所以考虑用 Endless Road 的 trick，每次只保留一个上升子序列，将一个上升子序列加入队列之后，把只被它二维偏序的点加入上升子序列中。这个过程考虑最开始求解上升子序列的方法，即找到后缀最小值。我们从左端点开始不断找到后缀最小值，找到一个之后再往后面跳，使用线段树维护。

要考虑两个问题：操作一个点对上升子序列的变化，一个点经过操作之后的值。

前者发现操作点对上升子序列的影响是一个区间，线段树维护即可。后者看似是二维偏序，但是直接根据题意可以拆成两个一维偏序，用树状数组维护即可。

所以总复杂度 $\mathcal{O}(n\log n)$。但是你写了四个线段树，四个 set 和两个树状数组，你感到很无语。

线段树没必要维护奇怪的下标，只需要在原下标下维护，没用的点值设为 $\inf$ 即可。当然写平衡树也可以。

### *CF1667D Edge Elimination

好题，喜欢。

首先条件有点丑，稍微想一下就可以发现条件相当于两边度数奇偶性相等，那么考虑按照度数奇偶性黑白染色，操作相当于选两个同色点的边，删掉并翻转两个点颜色。

猜测它是结论题，想想想，根本想不出来结论。

发现还是需要转化一下题意的。题意转化非常厉害：考虑对于每条边分配一个值，表示它是在两端点为度数为奇数还是偶数时变化的，条件相当于奇数有 $\left\lceil\dfrac{deg_i}{2}\right\rceil$，偶数是 $\left\lfloor\dfrac{deg_i}{2}\right\rfloor$。你发现叶子节点可以确定颜色，然后就可以 DP 了！太牛了！

仔细观察这个转化就可以发现，它将注意点将删边的排列放在了每个点奇偶性的变化上，当发现全局信息无法考虑的情况下，应该转化题意，将注意力放在更局部，更本质的问题上。